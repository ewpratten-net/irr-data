
# Commonly used variables
define OWNAS = {{ own_asn }};
router id {{ router_id }};

# Everyone shall announce least specific
protocol static {
    ipv6;
    route 2a12:dd47:9000::/36 unreachable;
} 

# Check function to see if IRR allows us to originate a prefix
function can_locally_originate_route() {
    if (net.type = NET_IP4) then {
        return net ~ [
            {{ self_origin_routes.ipv4 | join(', ') }}
        ];
    }
    if (net.type = NET_IP6) then {
        return net ~ [
            {{ self_origin_routes.ipv6 | join(', ') }}
        ];
    }
    return false;
}

# RPKI
{% include 'rpki.conf' %}

# Load utils and stuff 
{% include 'utils.conf' %}
{% include 'blackhole.conf' %}
{% include 'actions.conf' %}

# Kernel
filter local_import {
    if !can_locally_originate_route() then reject;
    accept;
}
filter kernel_export {
    reject_bogon_routes();
    if source = RTS_DEVICE then reject;
    krt_metric = 1100;
    accept;
}
protocol device {};
protocol direct { 
    ipv4 { import filter local_import; }; 
    ipv6 { import filter local_import; }; 
    interface "*";
}
protocol kernel {
    ipv4 {
        import filter local_import;
        export filter kernel_export;
    };
    learn;
    scan time 10;
    metric 0;
}
protocol kernel {
    ipv6 {
        import filter local_import;
        export filter kernel_export;
    };
    learn;
    scan time 10;
    metric 0;
}

# Peers
{% for peer in routing_policy %}
{% for address in peer.peer_neighbor_ips %}
{% if ":" in address %}
{% set address_kind = 6 %}
{% else %}
{% set address_kind = 4 %}
{% endif %}
protocol bgp {{ peer.name | upper }}_V{{ address_kind }}_{{ loop.index }} {
    local as {{ peer.own_as }};
    neighbor {{ address }} as {{ peer.peer_as }};

    {% if peer.multihop %}
    multihop;
    {% endif %}

    {% if peer.password %}
    password "{{ peer.password }}";
    {% endif %}

    {% set allowed_imports = peer.get_peer_allowed_routes() %}
    {% set allowed_exports = peer.get_allowed_routes_for_export() %}

    {% for num in [4,6] %}
    ipv{{ num }} {

        add paths;
        {% if peer.extended_nexthop %}
        extended next hop;
        {% endif %}

        import filter {
            # Filter out the bad
            reject_bogon_routes();
            reject_bogon_asns();
            reject_out_of_bounds_routes();
            reject_rpki_invalid();
            reject_transit_paths();
            honor_graceful_shutdown();

            # Prepend correct ASN if needed
            {% if peer.rewrite_as_to %}
            bgp_path.prepend({{ peer.rewrite_as_to }});
            {% endif %}

            # Only allow specified routes from the peer
            if (net.type = NET_IP4) then {
                {% if allowed_imports.ipv4 %}
                if !(net ~ [
                    {{ allowed_imports.ipv4 | join(', ') }}
                ]) then reject;
                {% else %}
                reject;
                {% endif %}
            }
            if (net.type = NET_IP6) then {
                {% if allowed_imports.ipv6 %}
                if !(net ~ [
                    {{ allowed_imports.ipv6 | join(', ') }}
                ]) then reject;
                {% else %}
                reject;
                {% endif %}
            }

            accept;
        };
        export filter {
            remove_private_asns();
            reject_bogon_routes();
            reject_out_of_bounds_routes();

            # Require paths to start with own as
            {% if "0.0.0.0/0{0,32}" not in allowed_exports.ipv4 and "::/0{0,128}" not in allowed_exports.ipv6 %}
            if bgp_path.len > 0 && bgp_path.first != OWNAS then reject;
            {% endif %}

            # Only allow specified routes to the peer
            if (net.type = NET_IP4) then {
                {% if allowed_exports.ipv4 %}
                    if !(net ~ [
                        {{ allowed_exports.ipv4 | join(', ') }}
                    ]) then reject;
                {% endif %}
            }
            if (net.type = NET_IP6) then {
                {% if allowed_exports.ipv6 %}
                    if !(net ~ [
                        {{ allowed_exports.ipv6 | join(', ') }}
                    ]) then reject;
                {% endif %}
            }

            accept;
        };
    };
    {% endfor %}

}
{% endfor%}
{% endfor %}

# Open a passive backbone connection on the main router
ipv6 table multihop_madness_v6;
protocol static {
    ipv6 {
        table multihop_madness_v6;
        import all;
    };
    route 2a12:dd47:9000::/48 via "backbone";
}
{% if router_id == '74.119.150.163' %}
protocol bgp backbone {
    local as OWNAS;
    neighbor range 2a12:dd47:9000::/48 as 4204466000;
    multihop;
    rs client;
    ipv4 {
        igp table multihop_madness_v6;
        extended next hop;
        add paths;
        next hop self;
        import where can_locally_originate_route();
        export where can_locally_originate_route();
    };
    ipv6 {
        igp table multihop_madness_v6;
        add paths;
        next hop self;
        import where can_locally_originate_route();
        export where can_locally_originate_route();
    };
}
{% else %}
protocol bgp backbone {
    local as 4204466000;
    neighbor 2a12:dd47:9000::1 as OWNAS;
    multihop;
    ipv4 {
        igp table multihop_madness_v6;
        extended next hop;
        add paths;
        next hop self;
        import where can_locally_originate_route();
        export where can_locally_originate_route();
    };
    ipv6 {
        igp table multihop_madness_v6;
        add paths;
        next hop self;
        import where can_locally_originate_route();
        export where can_locally_originate_route();
    };
}
{% endif %}